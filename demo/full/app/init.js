'use strict';

require.config({

  // Regular require config to define resources
  paths: {
    // jQuery
    'jquery': '//ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min',

    // AngularJS
    'angular': '//ajax.googleapis.com/ajax/libs/angularjs/1.3.9/angular.min',
    'angularRoute': '//ajax.googleapis.com/ajax/libs/angularjs/1.3.9/angular-route',
    'angularUi': '//cdnjs.cloudflare.com/ajax/libs/angular-ui-bootstrap/0.12.0/ui-bootstrap-tpls.min',

    // adhesive.js
    'angularConfig': '//rawgit.com/appmux/adhesive.js/master/dist/angular-config',
    'angularModular': '//rawgit.com/appmux/adhesive.js/master/dist/angular-modular',
    'angularCacheBuster': '//rawgit.com/appmux/adhesive.js/master/dist/angular-cachebuster',
    'angularTitle': '//rawgit.com/appmux/adhesive.js/master/dist/angular-title',

    // Third-party libraries
    // Add more third-party libraries as needed.
    // ...
    
    // In reality, all files above should be bundled together in one file
    // and minified, because we need them all no metter what.

    // Application: configuration and modules
    
    // This is the configuration for the entire application. It's a "must have"
    // for enterprise-level applications. Much easier to update one file
    // to change a behaviour of a module, especially if you have a complex
    // build-release process. Also, a config file may be generated by a content
    // management software, i.e. a CMS.
    // Take a look at that file and come back over here.
    'app/config': 'config/config',

    // This is the registry of application modules, these are handled
    // by ngModular auto-loader.
    // Reference to any module you ever build for your application using
    // adhesive.js framework should be listed here.
    
    // I like to call my main module "app" because it is what is it.
    // You can call it anything as long as you know it's your main application
    // module. Good alternative names would be:
    // module/main, module/core, etc.
    
    // Main application module is like an ambrella for everything else,
    // its purpose is to define global scope functionality and encapsulate
    // applicaiton wide components, i.e. finters, listeners, etc. commonly used
    // across all application modules.
    // Important: it does not handle any routes.
    'module/app': 'module/app/module',
    
    // The rest of modues are more specific ones to serve specific parts
    // of the applications, like different views and so on. they are packaged
    // accordingly, each will have it's own set or configuration, routes,
    // templates, controllers, services, filters and such.
    'module/index': 'module/index/module',
    'module/example': 'module/example/module'
  },
  shim: {
    // Now we need to define all dependencies at the AMD level. So we tell
    // require.js about other modules and their dependencies, which will load
    // required files in the proper order.
    // We don't need to shim jQuery, it's AMD-ready.
    'angular': {
      deps: ['jquery'],
      exports: 'angular'
    },
    'angularRoute': ['angular'],
    'angularUi': ['angular'],

    'angularConfig': ['angular'],
    'angularModular': ['angular'],
    'angularCacheBuster': ['angular'],
    'angularTitle': ['angular'],

    'module/app': [
      'angular',
      'angularRoute',
      'angularUi',
      'angularConfig',
      'angularModular',
      'angularCacheBuster',
      'angularTitle'
    ]
  },
  priority: [
    'angular'
  ]
});

// We all set up and ready for action. Let'start loading files.
require([
  'app/config',
  'module/app',
  'module/index'
], function(config, application, index) {
  
  // Above we listed only modules that we would like to have access to here.
  // They will pull their dependencies needed for the application to work,
  // but we don't really care about them here.
  angular.element().ready(function() {
    
    // Here we do our regular AngularJS set up, we create the main application
    // module and list all the native angular modules as dependencies.
    // Again, I like to call it app, but the name can be different and it has
    // nothing to do with module/app mentioned above.
    angular.module('app', [
      'ngRoute', 'ngConfig', 'ngModular', 'ngCacheBuster', 'ngTitle', 'ui.bootstrap'
    ])
    
      // At the onfiguration stage of angular's bootstrap process we pull some
      // dependencies to configure them. All this stuff is optional and exists
      // here only for demonstration of how it can be done when needed.
      .config(['configProvider', 'cacheBusterProvider', 'autoLoaderProvider', 'pageTitleProvider',
        function(configProvider, cacheBusterProvider, autoLoaderProvider, pageTitleProvider) {
          
          // We tell ngConfig to use our configuration object to make it
          // available across the entire application as an injectable
          // dependency 'config'.
          configProvider.configure(config);

          // We set up ngCacheBuster to bust cache for specific paths.
          cacheBusterProvider.setPaths(config.ngModule.ngCacheBuster.paths);
          cacheBusterProvider.setUrlParams(config.ngModule.ngCacheBuster.urlParams);

          // Example of implementaiton of a custom auto-loader's
          // path-to-module resolution function.
          autoLoaderProvider.addStrategy({
            name: 'alias',
            resolve: ['$location',
              function($location) {
                var moduleName = $location.path().split("/")[1];
                
                // Simple static definition, but can be implemented
                // in any custom way.
                if (moduleName == 'test') {
                  return 'module/example';
                }
              }
            ]
          });

          // Optional configuration for ngTitle
          pageTitleProvider.setPostfix(config.default.pageTitle);
          //pageTitleProvider.setDelimiter(' | ');
        }
      ]);
      
      // Here we call the ngModular module that will drive the rest of the
      // application. This very module allows to have the application better
      // organized in sense of files and module structure and dynamically load
      // application modules on demand.
      
      // So let's bootstrap this thing up!
      // Note, on the background, ngModular calls the regular bootstrap process
      // that will engage the 'app' module defined in the section above
      // and will run it throung the config and run stages.
      
      // One little thing to note, here we tell ngModular to automatically
      // pre-load two application modules:
      // application - which is the main module/app, and
      // index - which is the default view module that handles the root #/ route
      angular.module('ngModular').bootstrap(document, ['app'], [application, index]);
      
      // Our application has started, so let's see how it works, proceed to the
      // app/module/app/module.js file, I'll meet you there.
  });
});